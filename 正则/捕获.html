<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

    <script>
    
    
    
    let  str = 'zym2019zss20110yyy'  //解决正则捕获的懒惰性，全局修饰符g
        
    let reg  = /\d+/g //设置g后 lastIndex值会默认修改     

    // console.log(reg.exec(str)); //默认只捕获第一个 正则的懒惰性 
    // console.log(reg.exec(str))
    // 捕获懒惰性的原因，默认情况下lastIndex的值不会改变 每一次都是从字符串开始位置查找,所以找到的永远只是第一个

    // 只要设置了全局修饰符g 使用了reg的方法后 lastIndex的值都会被改变


    // console.log(str.match(reg));

    // 手写一个正则match 

    // ~function(){
    //     function execAll(str){


    //         let arr = []
    //         let res = this.exec(str)
    //         while(res){


                
    //             arr.push(res[0])
    //             res = this.exec(str)
    //         }
    //         return arr
    //     }

    //     RegExp.prototype.execAll = execAll
    // }()


//   ~function 是一个自执行匿名函数 代替匿名函数的小括号
    //     ~function(){
    //         function execAll(str){
    //             // 第一步 执行reg.exec 哪里的reg.exec  this指向的reg.exec
    //         let   res = this.exec(str) //匹配到第一次 如果匹配得到
    //         let   arr = []
    //             while(res){
    //                 arr.push(res[0])
    //                 res = this.exec(str)
    //             }
    //             return arr

    //         }
    //         RegExp.prototype.execAll = execAll
    //     }()

    // console.log(reg.execAll(str));

    //test也能捕获
    let str = "{0}年{1}月{2}日"
    let reg = /\{(\d+)\}/g
    
    console.log(reg.test(str)); //=> true
    console.log(RegExp.$1);    //=> 0

    console.log(reg.test(str)); //=> true
    console.log(RegExp.$1);    //=> 1

    console.log(reg.test(str)); //=> true
    console.log(RegExp.$1);    //=> 2

    console.log(reg.test(str)); //=> false
    console.log(RegExp.$1);    //=> 2 存储的是上次捕获的结果
    
    
    
    </script>
    
</body>
</html>